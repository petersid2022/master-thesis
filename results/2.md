# command line

./bin/llama-speculative-simple -m  ../../models/Llama-3.2-3B-Instruct-Q5_K_M.gguf -md ../../models/Llama-3.2-3B-Instruct-IQ3_M.gguf -f test.txt -c 0 --color

--------------------------------------------------

# prompt 

Wed Nov 12 11:28:58 UTC 2025: cat test.txt \
how does speculative execution work?

--------------------------------------------------

# output

```
<|begin_of_text|>how does speculative execution work? and what are the its potential risks?

Speculative execution is a technique used in modern CPU architectures to improve performance by executing instructions before they are known to be needed. Here's how it works:

**How Speculative Execution Works:**
1. **Branch Prediction:** The CPU uses branch prediction to guess which branch a program will take. If the prediction is correct, the CPU executes the instructions before the branch point. If the prediction is incorrect, the CPU can revert to the previous state of the program.
2. **Predictable Paths:** The CPU identifies predictable paths through the program and executes them in parallel, allowing multiple in structions to be executed simultaneously.
3. **Speculative Execution:** When the CPU detects a predictable path, it begins executing instructions in that path, even if it's not yet certain which branch will be taken.
4. **Branch Target Buffer (BTB):** The BTB stores the history of recent branch decisions. It helps the CPU predict future branches.

**Potential Risks:**
1. **Side-channel Attacks:** Speculative execution can be exploited by attackers to access sensitive information, such as encryption keys or memory contents. This is because the CPU may execute instructions before they are known to be needed, allowing attackers to infer information about the program's state.
2. **Information Leaks:** Speculative execution can also cause information leaks, where sensitive information is leaked to adjacent processes or memory locations.
3. **Data Exposure:** In some cases, speculative execution can cause data to be exposed to unauthorized parties, such as when sensitive data is cached in the CPU's cache.
4. **Denial-of-Service (DoS) Attacks:** Speculative execution can be used to launch DoS attacks by flooding the CPU with instructions, causing it to consume excessive resources and become unresponsive.
5. **Code Injection:** Speculative execution can be used to inject malicious code into a program's cache, allowing attackers to execute arbitrary instructions.

**Mitigation Techniques:**
1. **Sandboxing:** Running applications in a sandboxed environment can help prevent attacks that rely on speculative execution.
2. **Address Space Layout Randomization (ASLR):** ASLR randomizes the location of sensitive data in memory, making it harder for attackers to exploit.
3. **Data Execution Prevention (DEP):** DEP prevents code from being executed in non-code areas of memory.
4. **Code Integrity:** Verifying the integrity of code at runtime can help prevent malicious code from being injected into the program's cache.
5. **Software-based mitigations:** Developers can use software-based mitigations, such as disabling speculative execution or using alternative execution modes, to reduce the risk of attacks.

In summary, speculative execution is a powerful technique for improving CPU performance, but it also introduces potential risks. By understanding how speculative execution works and its potential risks, developers can take steps to mitigate these risks and ensure the security and integrity of their applications.
```

--------------------------------------------------

# llama.cpp logs

```
encoded    7 tokens in    0.212 seconds, speed:   32.951 t/s
decoded  595 tokens in   94.432 seconds, speed:    6.301 t/s

n_draft   = 16
n_predict = 595
n_drafted = 531
n_accept  = 401
accept    = 75.518%

draft:

llama_perf_context_print:        load time =    6071.78 ms
llama_perf_context_print: prompt eval time =   20366.85 ms /   193 tokens (  105.53 ms per token,     9.48 tokens per second)
llama_perf_context_print:        eval time =   47959.19 ms /   437 runs   (  109.75 ms per token,     9.11 tokens per second)
llama_perf_context_print:       total time =   94646.67 ms /   630 tokens
llama_perf_context_print:    graphs reused =        436

target:

llama_perf_sampler_print:    sampling time =      77.49 ms /   595 runs   (    0.13 ms per token,  7678.41 tokens per second)
llama_perf_context_print:        load time =    5887.03 ms
llama_perf_context_print: prompt eval time =   26262.36 ms /   731 tokens (   35.93 ms per token,    27.83 tokens per second)
llama_perf_context_print:        eval time =       0.00 ms /     1 runs   (    0.00 ms per token,      inf tokens per second)
llama_perf_context_print:       total time =  100718.50 ms /   732 tokens
llama_perf_context_print:    graphs reused =         44
llama_memory_breakdown_print: | memory breakdown [MiB] | total   free     self   model   context   compute    unaccounted |
llama_memory_breakdown_print: |   - Host               |                 16951 =  2207 +   14336 +     408                |
```

<!-- vim: nofoldenable
